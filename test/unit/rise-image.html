<!doctype html>

<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <script src="../../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../node_modules/@polymer/test-fixture/test-fixture.js"></script>
    <script src="../../node_modules/mocha/mocha.js"></script>
    <script src="../../node_modules/chai/chai.js"></script>
    <script src="../../node_modules/sinon/pkg/sinon.js"></script>
    <script src="../../node_modules/wct-mocha/wct-mocha.js"></script>
    <script>
      const SAMPLE_PATH = 'risemedialibrary-30007b45-3df0-4c7b-9f7f-7d8ce6443013/logo.png';
      const SAMPLE_PATH2 = 'risemedialibrary-30007b45-3df0-4c7b-9f7f-7d8ce6443014/logo.png';
      const SAMPLE_URL = `https://storage.googleapis.com/${ SAMPLE_PATH }`;

      RisePlayerConfiguration = {
        isConfigured: () => true,
        isPreview: () => false,
        Branding: {
          watchLogoFile: () => {}
        },
        LocalStorage: {
          watchSingleFile: () => {}
        }
      };
    </script>
    <script src="../../src/rise-image.js" type="module"></script>
  </head>
  <body>
    <test-fixture id="test-block">
      <template>
        <rise-image
          width="300"
          height="240"
          sizing="contain"
          position="top"
          files="risemedialibrary-30007b45-3df0-4c7b-9f7f-7d8ce6443013/logo.png">
        </rise-image>
      </template>
    </test-fixture>

    <script>
      suite( "rise-image", () => {
        let element;

        setup(() => {
          RisePlayerConfiguration.Logger = {
            info: () => {},
            warning: () => {},
            error: () => {}
          };

          RisePlayerConfiguration.Helpers = {
            isEditorPreview: () => {return false;}
          };

          RisePlayerConfiguration.isPreview = () => false;

          element = fixture("test-block");
        });

        suite( "_isValidFilesString", () => {
          test( "should return true if 'files' attribute is a non-empty String", () => {
            assert.isTrue( element._isValidFilesString( "test" ) );
          } );
           test( "should return false if 'files' attribute is not a String or empty String", () => {
            assert.isFalse( element._isValidFilesString( 123 ) );
            assert.isFalse( element._isValidFilesString( ["test1|test2"] ) );
            assert.isFalse( element._isValidFilesString( "" ) );
          } );
           test( "should return true if 'files' attribute is a String containing values separated by '|'", () => {
            assert.isTrue( element._isValidFilesString( "test1|test2|test3" ) );
          } );
           test( "should return false if 'files' attribute contains '|' with any empty value", () => {
            assert.isFalse(element._isValidFilesString("test|"));
            assert.isFalse(element._isValidFilesString("|test"));
            assert.isFalse(element._isValidFilesString("|"));
            assert.isFalse(element._isValidFilesString("test1|test2||test3"));
          } );
        } );

        suite( "_getDataUrlFromSVGLocalUrl", () => {
          let xhr,
            requests;

          setup( () => {
            xhr = sinon.useFakeXMLHttpRequest();
            requests = [];

            xhr.onCreate = ( request ) => {
              requests.push( request );
            };
          });

          teardown( () => {
            xhr.restore();
          });

          test( "should get a data url response", function() {
            const svg = `...`;
            const blob = new Blob([svg], {type: 'image/svg+xml'});

            let promise = element._getDataUrlFromSVGLocalUrl( "" )
              .then( function( dataUrl ) {
                assert( dataUrl );
                assert.include( dataUrl, "data:image/svg+xml;base64");
              });

            requests[ 0 ].respond( 200, { "Content-Type": "blob" }, `${blob}` );

            return promise;
          });

          test( "should return an error if xhr request fails", function() {
            let promise = element._getDataUrlFromSVGLocalUrl( "" )
              .catch( error => {
                assert( error );
                assert.include( error, "404" );
              } );

            requests[ 0 ].respond( 404, {}, "" );

            return promise;
          });

        });

        suite( "_getFilesFromMetadata", () => {
          test( "should handle null metadata value", () => {
            assert.deepEqual( element._getFilesFromMetadata(), []);
          } );

          test( "should return correct list of files", () => {
            element.metadata = [
              { file: "test1.jpg", "thumbnail-url": "http://test1.jpg", exists: true },
              { file: "test2.jpg", "thumbnail-url": "http://test2.jpg", exists: true },
              { file: "test3.jpg", "thumbnail-url": "http://test3.jpg", exists: true }
            ]
            assert.deepEqual( element._getFilesFromMetadata(), [
              "test1.jpg", "test2.jpg", "test3.jpg"
            ]);
          } );

          test( "should handle empty metadata value", () => {
            element.metadata = [];
            assert.deepEqual( element._getFilesFromMetadata(), []);
          } );
        } );

        suite( "_hasMetadata", () => {
          test( "should return correct value", () => {
            // null value
            assert.isFalse( element._hasMetadata());

            element.metadata = [];
            assert.isFalse( element._hasMetadata() );

            element.metadata = [
              { file: "test1.jpg", "thumbnail-url": "http://test1.jpg", exists: true },
              { file: "test2.jpg", "thumbnail-url": "http://test2.jpg", exists: true },
              { file: "test3.jpg", "thumbnail-url": "http://test3.jpg", exists: true }
            ];
            assert.isTrue( element._hasMetadata() );
          } );
        } );

        suite( "_filePathIsRendered", () => {
          test( "should find the file", () => {
            element._filesToRenderList = [
              { filePath: "a.png" },
              { filePath: "b.png" },
              { filePath: "c.png" }
            ];

            const image = element._filePathIsRendered( "b.png" );
            assert.deepEqual(image, { filePath: "b.png" });
          } );
        } );

        suite( "_reset", () => {
          setup( () => {
            sinon.stub( element, "_start" );
          } );

          teardown( () => {
            element._start.restore();
          } );

          test( "should reset internals, clear displayed image, and call _start() only if not initial start", () => {
            sinon.spy( element, "_clearDisplayedImage" );

            element._initialStart = false;
            element._watchInitiated = true;
            element._validFiles = [ SAMPLE_PATH ];
            element.managedFiles = [ { filePath: SAMPLE_PATH, fileUrl: SAMPLE_URL, order: 0 } ];
            element._filesToRenderList = [ { filePath: SAMPLE_PATH, fileUrl: SAMPLE_URL, order: 0 } ];
            element._managedFilesInError = [ { filePath: "test path", fileUrl: "test url", order: 1 } ];
            element._transitionTimer = 12345;
            element._transitionIndex = 3;
            element._reset();

            assert.isFalse( element._watchInitiated );
            assert.isEmpty( element._validFiles );
            assert.isEmpty( element.managedFiles );
            assert.isEmpty( element._managedFilesInError );
            assert.isEmpty( element._filesToRenderList );
            assert.isNull( element._transitionTimer );
            assert.equal( element._transitionIndex, 0 );
            assert.isTrue( element._clearDisplayedImage.called );
            assert.isTrue( element._start.calledOnce );
          } );

        } );

        suite( "_renderImage", () => {
          setup( () => {
            sinon.spy( element.$.image, "updateStyles" );
            sinon.stub(element, "_getDataUrlFromSVGLocalUrl").callsFake(() => {
              return Promise.resolve("dataurl");
            });
            sinon.stub(element, '_renderImageForPreview');
          } );

          teardown( () => {
            element.$.image.updateStyles.restore();
            element._getDataUrlFromSVGLocalUrl.restore();
            element._renderImageForPreview.restore();
            RisePlayerConfiguration.isPreview = () => false;
          } );

          test( "should ignore width/height/sizing/position and apply responsive styling", () => {
            element.responsive = true;

            element._renderImage( SAMPLE_PATH, SAMPLE_URL );

            assert.isTrue(element.$.image.updateStyles.calledWith({ "--iron-image-width": "100%", "width": "100%", "height": "auto", "display": "inline-block" }));
            assert.equal(element.$.image.style.width, "100%");
            assert.equal(element.$.image.style.height, "auto");
            assert.equal(getComputedStyle(element.$.image).getPropertyValue("--iron-image-width"), "100%");
            assert.isNull(element.$.image.width);
            assert.isNull(element.$.image.height);
            assert.isNull(element.$.image.sizing);
            assert.equal(element.$.image.position, "center"); // iron-image enforces "center" as default value
          } );

          test( "should apply fixed width/height/sizing/position", () => {
            element._renderImage( SAMPLE_PATH, SAMPLE_URL );

            assert.isTrue(element.$.image.updateStyles.calledWith({"display": "inline-block"}));
            assert.equal(element.$.image.width, 300);
            assert.equal(element.$.image.height, 240);
            assert.equal(element.$.image.sizing, "contain");
            assert.equal(element.$.image.position, "top");

          } );

          test( "should attempt to get data url when format is SVG", () => {
            element._renderImage( "risemedialibrary-abc123/test.svg", "https://storage.googleapis.com/risemedialibrary-abc123/test.svg" );

            assert.isTrue( element._getDataUrlFromSVGLocalUrl.called );
          } );

          test( "should call _renderImageForPreview() when running in Preview", () => {
            RisePlayerConfiguration.isPreview = () => true;

            element._renderImage( "risemedialibrary-abc123/test.jpg", "https://storage.googleapis.com/risemedialibrary-abc123/test.jpg" );

            assert.isTrue( element._renderImageForPreview.called );
          } );
        } );

        suite( "_renderImageForPreview", () => {
          setup( () => {
            sinon.stub(element.__proto__.__proto__.__proto__, "getFile").resolves("test object url");
          } );

          teardown( () => {
            element.__proto__.__proto__.__proto__.getFile.restore();
          } );

          test( "should make getFile() call of StoreFilesMixin with correct file url", () => {
            element._renderImageForPreview("https://storage.googleapis.com/risemedialibrary-abc123/test1.png?_=");

            assert.isTrue(element.getFile.calledWith("https://storage.googleapis.com/risemedialibrary-abc123/test1.png?_=", false));
          } );

          test( "should set src of image with object url", (done) => {
            element._renderImageForPreview("https://storage.googleapis.com/risemedialibrary-abc123/test1.png?_=");

            setTimeout(() => {
              assert.isTrue(element.getFile.calledWith("https://storage.googleapis.com/risemedialibrary-abc123/test1.png?_=", false));
              assert.equal(element.$.image.src, "test object url");
              done();
            }, 100);
          } );

          test( "should set flag to omit checking cached status if running on Editor Preview", () => {
            sinon.stub(RisePlayerConfiguration.Helpers, "isEditorPreview").returns(true);

            element._renderImageForPreview("https://storage.googleapis.com/risemedialibrary-abc123/test1.png?_=");

            assert.isTrue(element.getFile.calledWith("https://storage.googleapis.com/risemedialibrary-abc123/test1.png?_=", true));
          } );
        } );

        suite( "_getFileUrl", () => {
          test( "should encode file path", (done) => {
            let filePath = "risemedialibrary-30007b45-3df0-4c7b-9f7f-7d8ce6443013/unit-test-do-not-delete/Ü-+ test%20encoding ([!@?,#$])=1+2-A&%.jpg";
            let fileUrl = element._getFileUrl( filePath );

            assert.isTrue(fileUrl.indexOf("/risemedialibrary-30007b45-3df0-4c7b-9f7f-7d8ce6443013/") > 0, "forward slash in file path is not encoded" );

            fetch(fileUrl)
              .then( (res) => {
                assert.isTrue(res.status === 200);
                done();
              } )
              .catch( (error) => {
                assert.fail( error );
                done();
              } );
          });
        } );

        suite( "_handleStartForPreview", () => {
          setup( () => {
            sinon.stub(element.__proto__.__proto__, "handleFileStatusUpdated");
          });

          teardown( () => {
            element.metadata = null;

            element.handleFileStatusUpdated.restore();
          } );

          test( "should call handleFileStatusUpdated with correct data", () => {
            element._validFiles = [ "risemedialibrary-30007b45-3df0-4c7b-9f7f-7d8ce6443013/logo.png" ];
            element._handleStartForPreview();

            assert.isTrue( element.handleFileStatusUpdated.calledWith({
              filePath: "risemedialibrary-30007b45-3df0-4c7b-9f7f-7d8ce6443013/logo.png",
              fileUrl: "https://storage.googleapis.com/risemedialibrary-30007b45-3df0-4c7b-9f7f-7d8ce6443013/logo.png?_=",
              status: "current"
            } ));
          } );

          test( "should call handleFileStatusUpdated for each file", () => {
            element._validFiles = [ "risemedialibrary-abc123/test1.png", "risemedialibrary-abc123/test2.png", "risemedialibrary-abc123/test3.png" ];
            element._handleStartForPreview();

            assert.deepEqual( element.__proto__.__proto__.handleFileStatusUpdated.args[0][0], {
              filePath: "risemedialibrary-abc123/test1.png",
              fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/test1.png?_=",
              status: "current"
            } );

            assert.deepEqual( element.__proto__.__proto__.handleFileStatusUpdated.args[1][0], {
              filePath: "risemedialibrary-abc123/test2.png",
              fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/test2.png?_=",
              status: "current"
            } );

            assert.deepEqual( element.__proto__.__proto__.handleFileStatusUpdated.args[2][0], {
              filePath: "risemedialibrary-abc123/test3.png",
              fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/test3.png?_=",
              status: "current"
            } );
          } );

          test( "should call handleFileStatusUpdated with correct data and time created", () => {
            const file = "risemedialibrary-30007b45-3df0-4c7b-9f7f-7d8ce6443013/logo.png";
            element._validFiles = [ file ];
            element.metadata = [
              { file, exists: true, "time-created": 123 }
            ];
            element._handleStartForPreview();

            assert.isTrue( element.__proto__.__proto__.handleFileStatusUpdated.calledWith({
              filePath: "risemedialibrary-30007b45-3df0-4c7b-9f7f-7d8ce6443013/logo.png",
              fileUrl: "https://storage.googleapis.com/risemedialibrary-30007b45-3df0-4c7b-9f7f-7d8ce6443013/logo.png?_=123",
              status: "current"
            } ));
          } );

        } );

       suite( "uptime", () => {
          const sandbox = sinon.createSandbox();

          setup( () => {
            sandbox.stub(element.__proto__.__proto__, '_setUptimeError');
            sandbox.stub(element.$, 'image');
          });

          teardown( () => {
            sandbox.restore();
          });

          test("should default to no uptime error", () => {
            assert.isFalse( element._setUptimeError.called );
          });

          test("should set uptime error when raising image-error", () => {
            element._sendImageEvent("image-error");
            assert.isTrue( element._setUptimeError.called );
            assert.isTrue( element._setUptimeError.calledWith(true) );
          });

          test("should report no uptime error on reset", () => {
            element._sendImageEvent("image-reset");
            assert.isTrue( element._setUptimeError.called );
            assert.isTrue( element._setUptimeError.calledWith(false) );
          });

          test("should not change uptime error status on other events", () => {
            element._sendImageEvent("configured");
            assert.isFalse( element._setUptimeError.called );
          });

          test("should report no uptime error when image is loaded", done => {
            element.$.image.dispatchEvent( new CustomEvent( "loaded-changed", { detail: { value: true } }));
            setTimeout(() => {
              assert.isTrue( element._setUptimeError.called );
              assert.isTrue( element._setUptimeError.calledWith(false) );
              done();
            },10);
          });

          test("should not call _setUptimeError if value of 'loaded' is false", done => {
            element.$.image.dispatchEvent( new CustomEvent( "loaded-changed", { detail: { value: false } }));
            setTimeout(() => {
              assert.isFalse( element._setUptimeError.called );
              done();
            },10);
          });

        });

        suite( "Play Until Done", () => {

          suite( "_isDone()", () => {

            test("should return false when element is not configured for PUD", () => {
              assert.isFalse( element._isDone());
            });

            test("should return true when element is configured for PUD and transition index is last element", () => {
              element.setAttribute( "play-until-done", true);

              element._transitionIndex = 0;
              element._filesToRenderList = [{"filePath":"risemedialibrary-7fa5ee92-7deb-450b-a8d5-e5ed648c575f/DSC01624.JPG"}];

              assert.isTrue( element._isDone());
            });

            test("should return false when element is configured for PUD and transition index is not last element", () => {
              element.setAttribute( "play-until-done", true);

              element._transitionIndex = 0;
              element._filesToRenderList = [{ filePath: "risemedialibrary-7fa5ee92-7deb-450b-a8d5-e5ed648c575f/DSC01624.JPG"}, { filePath: "risemedialibrary-30007b45-3df0-4c7b-9f7f-7d8ce6443013/logo.png"}];

              assert.isFalse( element._isDone());
            });

          });

          suite( "_onShowImageComplete()", () => {
            const sandbox = sinon.createSandbox();

            setup( () => {
              sandbox.stub(element.__proto__.__proto__, '_sendDoneEvent');
              sandbox.spy(element, "_configureShowingImages");
              sandbox.spy(element, "_startTransitionTimer");
            });

            teardown( () => {
              sandbox.restore();
            });

            test("should send report-done event when it is done", () => {
              element.setAttribute( "play-until-done", true);

              element._transitionIndex = 0;
              element._filesToRenderList = [{ filePath: "risemedialibrary-7fa5ee92-7deb-450b-a8d5-e5ed648c575f/DSC01624.JPG"}];

              element._onShowImageComplete();

              assert.isTrue( element._sendDoneEvent.calledWith(true) );
            });

             test("should keep transitioning the images when it is done", () => {
              element.setAttribute( "play-until-done", true);

              element._transitionIndex = 0;
              element._filesToRenderList = [{ filePath: "risemedialibrary-7fa5ee92-7deb-450b-a8d5-e5ed648c575f/DSC01624.JPG"}, { filePath: "risemedialibrary-7fa5ee92-7deb-450b-a8d5-e5ed648c575f/DSC01625.JPG"}];

              element._onShowImageComplete();

              assert.equal( element._transitionIndex, 1);
            });

            test("should only start transition timer if managing single image", () => {
              element.setAttribute( "play-until-done", true);

              element._transitionIndex = 0;
              element._filesToRenderList = [{ filePath: "risemedialibrary-abc123/test.jpg", fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/test.jpg"}];

              element._onShowImageComplete();

              assert.isTrue( element._startTransitionTimer.called);
              assert.isFalse( element._configureShowingImages.called);
            });

            test("should only call _configureShowingImages when managing multiple images and cycle is complete", () => {
              element.setAttribute( "play-until-done", true);

              element._transitionIndex = 2;
              element._filesToRenderList = [{ filePath: "risemedialibrary-abc123/test1.jpg", fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/test1.jpg"}, { filePath: "risemedialibrary-abc123/test2.jpg", fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/test2.jpg"}, { filePath: "risemedialibrary-abc123/test3.jpg", fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/test3.jpg"}];

              element._onShowImageComplete();

              assert.isFalse( element._startTransitionTimer.called);
              assert.isTrue( element._configureShowingImages.called);
            });

          });

          suite( "_startEmptyPlayUntilDoneTimer()", () => {
            const sandbox = sinon.createSandbox();

            setup( () => {
              sandbox.stub(element, '_startEmptyPlayUntilDoneTimer');
              sandbox.stub(element.__proto__.__proto__, 'log');
            });

            teardown( () => {
              sandbox.restore();
            });

            test("should start empty play until done timer on empty files list", () => {
              element.setAttribute( "play-until-done", true);

              element.files = "";

              element._start();

              assert.isTrue( element._startEmptyPlayUntilDoneTimer.called );
            });

            test("should start empty play until done timer on invalid files list", () => {
              element.setAttribute( "play-until-done", true);

              element.files = "risemedialibrary-abc123/README.md";

              element._start();

              assert.isTrue( element._startEmptyPlayUntilDoneTimer.called );
            });

            test("should start empty play until done timer if file list includes single file and it does not exist", () => {
              element.setAttribute( "play-until-done", true);

              element._transitionIndex = 0;
              element._validFiles = [ SAMPLE_PATH ];

              element._handleSingleFileError({filePath: SAMPLE_PATH, status: "NOEXIST"});

              assert.isTrue( element._startEmptyPlayUntilDoneTimer.called );
            });

            test("should start empty play until done timer if file list includes 2 files and both do not exist", () => {
              element.setAttribute( "play-until-done", true);

              element._transitionIndex = 0;
              element._validFiles = [ SAMPLE_PATH,  SAMPLE_PATH2];

              element._handleSingleFileError({filePath: SAMPLE_PATH, status: "NOEXIST"});
              element._handleSingleFileError({filePath: SAMPLE_PATH2, status: "NOEXIST"});

              assert.isTrue( element._startEmptyPlayUntilDoneTimer.called );
            });

            test("should start empty play until done timer if file list includes 2 images with the same path and file do not exist", () => {
              element.setAttribute( "play-until-done", true);

              element._transitionIndex = 0;
              element._validFiles = [ SAMPLE_PATH,  SAMPLE_PATH];

              element._handleSingleFileError({filePath: SAMPLE_PATH, status: "NOEXIST"});

              assert.isTrue( element._startEmptyPlayUntilDoneTimer.called );
            });

          });

          suite( "_startEmptyPlayUntilDoneTimer function", () => {
            const sandbox = sinon.createSandbox();

            setup( () => {
              sandbox.stub(window, 'clearTimeout');
              sandbox.stub(window, 'setTimeout');
            });

            teardown( () => {
              sandbox.restore();
            });

            test("should start empty play until done timer on empty files list", () => {
              element.setAttribute( "play-until-done", true );

              element._startEmptyPlayUntilDoneTimer();

              assert.isTrue( window.clearTimeout.called );
              assert.isTrue( window.setTimeout.called );
            });
          });

        });

        suite( "branding", () => {
          suite( "element.isLogo", () => {
            test( "should default to isLogo = false", () => {
              assert.equal( element.isLogo, false );
            });

            test( "should call _isLogoChanged when isLogo is changed", () => {
              sinon.stub(element, "_isLogoChanged");

              element.isLogo = true;

              assert.isTrue( element._isLogoChanged.called );
            });

          });

          suite( "element.logoFile", () => {
            test( "should be readonly property", () => {
              assert.equal( element.logoFile, "" );

              element.logoFile = "testFile.jpg";

              assert.equal( element.logoFile, "" );
            });

            test( "should update via setter", () => {
              assert.equal( element.logoFile, "" );

              element._setLogoFile( "testFile.jpg" );

              assert.equal( element.logoFile, "testFile.jpg" );
            });

          });

          suite( "_isLogoChanged", () => {
            var unregisterSpy;

            setup( () => {
              unregisterSpy = sinon.spy();

              sinon.stub( RisePlayerConfiguration.Branding, "watchLogoFile" ).returns( unregisterSpy );
            });

            teardown( () => {
              RisePlayerConfiguration.Branding.watchLogoFile.restore();
            });

            test( "should attach logoFile watcher", () => {
              element.isLogo = true;

              assert.isTrue( RisePlayerConfiguration.Branding.watchLogoFile.calledWith( sinon.match.func ));
            });

            test( "should attach logoFile watcher, once", () => {
              element.isLogo = true;

              assert.isTrue( RisePlayerConfiguration.Branding.watchLogoFile.calledWith( sinon.match.func ));

              element._isLogoChanged();

              assert.isTrue( RisePlayerConfiguration.Branding.watchLogoFile.calledOnce );
            });

            test( "should set logoFile when watcher is called", () => {
              element.isLogo = true;

              assert.isTrue( RisePlayerConfiguration.Branding.watchLogoFile.calledWith( sinon.match.func ));

              RisePlayerConfiguration.Branding.watchLogoFile.getCall(0).args[0]("sampleLogo.jpg");

              assert.equal( element.logoFile, "sampleLogo.jpg");
            });

            test( "should detach logoFile watcher", () => {
              element.isLogo = true;

              assert.isTrue( RisePlayerConfiguration.Branding.watchLogoFile.calledOnce );

              element.isLogo = false;

              assert.isTrue( RisePlayerConfiguration.Branding.watchLogoFile.calledOnce );
              assert.isTrue( unregisterSpy.calledOnce );
            });

            test( "should detach logoFile watcher once", () => {
              element.isLogo = true;

              assert.isTrue( RisePlayerConfiguration.Branding.watchLogoFile.calledOnce );

              element.isLogo = false;

              assert.isTrue( unregisterSpy.calledOnce );

              element._isLogoChanged();

              assert.isTrue( unregisterSpy.calledOnce );
            });

            test( "should reset logoFile", () => {
              element.logoFile = "someFile.jpg";
              element.isLogo = true;

              assert.isTrue( RisePlayerConfiguration.Branding.watchLogoFile.calledOnce );

              element.isLogo = false;

              assert.equal( element.logoFile, "");
            });

          });

          suite( "_start", () => {
            setup( () => {
              element.metadata = [{
                "file": "risemedialibrary-7fa5ee92-7deb-450b-a8d5-e5ed648c575f/apache.png",
                "exists": true
              }, {
                "file": "risemedialibrary-abc123/README.md",
                "exists": true
              }];

              RisePlayerConfiguration.LocalMessaging = {
                isConnected: () => { return true; }
              }
            });

            test( "should set _validFiles to logoFile if it exists", () => {
              assert.isOk( element.files );
              assert.isOk( element.metadata );

              element._setLogoFile("risemedialibrary-abc123/testFile.jpg");

              element._start();

              assert.deepEqual( element._validFiles, [ "risemedialibrary-abc123/testFile.jpg" ]);
            });

            test( "should set _validFiles to metadata if logoFile is blank", () => {
              assert.isOk( element.files );
              assert.isOk( element.metadata );

              element._setLogoFile("");

              element._start();

              assert.deepEqual( element._validFiles, [ "risemedialibrary-7fa5ee92-7deb-450b-a8d5-e5ed648c575f/apache.png" ]);
            });

            test( "should set _validFiles to files if logoFile and metadata are blank", () => {
              assert.isOk( element.files );

              element.metadata = "";
              element._setLogoFile("");

              element._start();

              assert.deepEqual( element._validFiles, [ "risemedialibrary-30007b45-3df0-4c7b-9f7f-7d8ce6443013/logo.png" ]);
            });

          });
        });

        suite( "_previewStatusFor", () => {
          test( "should get current status if there is no metadata", () => {
            element.metadata = [];

            const status = element._previewStatusFor( 'risemedialibrary-abc123/README.md' );

            assert.equal( status, "current" );
          });

          test( "should ignore metadata and return 'current' status if is logo", () => {
            element.metadata = [{
              "file": "risemedialibrary-abc123/logo.png",
              "exists": false
            }];
            element.isLogo = true;

            const status = element._previewStatusFor( 'risemedialibrary-abc123/logo.png' );

            assert.equal( status, "current" );
          });

          test( "should get current status if metadata says that file exists", () => {
            element.metadata = [{
              "file": "risemedialibrary-7fa5ee92-7deb-450b-a8d5-e5ed648c575f/apache.png",
              "exists": true
            }, {
              "file": "risemedialibrary-abc123/README.md",
              "exists": true
            }];

            const status = element._previewStatusFor( 'risemedialibrary-abc123/README.md' );

            assert.equal( status, "current" );
          });

          test( "should get deleted status if metadata says that file doesn't exist", () => {
            element.metadata = [{
              "file": "risemedialibrary-7fa5ee92-7deb-450b-a8d5-e5ed648c575f/apache.png",
              "exists": true
            }, {
              "file": "risemedialibrary-abc123/README.md",
              "exists": false
            }];

            const status = element._previewStatusFor( 'risemedialibrary-abc123/README.md' );

            assert.equal( status, "deleted" );
          });

          test( "should get deleted status if metadata is not empty but does not contain the file", () => {
            element.metadata = [{
              "file": "risemedialibrary-7fa5ee92-7deb-450b-a8d5-e5ed648c575f/apache.png",
              "exists": true
            }];

            const status = element._previewStatusFor( 'risemedialibrary-abc123/README.md' );

            assert.equal( status, "deleted" );
          } );

        });

        suite( "watchedFileDeletedCallback", () => {
           const sandbox = sinon.createSandbox();

           setup( () => {
             sandbox.stub(element, '_clearDisplayedImage');
           });

           teardown( () => {
             sandbox.restore();
           });

          test( "should clear displayed image if the only image was deleted", () => {
            element._filesToRenderList = [
              { filePath: "a.txt" }
            ];

            element.watchedFileDeletedCallback({ filePath: "a.txt" });

            assert.deepEqual( element._filesToRenderList, [] );
            assert.equal( element._clearDisplayedImage.callCount, 1 );
          });
        });

        suite( "watchedFileAddedCallback", () => {
          const sandbox = sinon.createSandbox();

          setup( () => {
            sandbox.stub(element, '_configureShowingImages');
          });

          teardown( () => {
            sandbox.restore();
            RisePlayerConfiguration.isPreview = () => false;
          });

          test( "should not call configureShowingImages when running in Preview and full list isn't managed yet", () => {
            RisePlayerConfiguration.isPreview = () => true;

            element._validFiles = [ "risemedialibrary-abc123/testing/a.jpg", "risemedialibrary-abc123/testing/b.jpg", "risemedialibrary-abc123/testing/c.jpg" ];
            element.managedFiles = [ {
              filePath: "risemedialibrary-abc123/testing/a.jpg",
              fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/testing/a.jpg",
              order: 0
            } ]

            element.watchedFileAddedCallback();

            assert.isFalse( element._configureShowingImages.called );
          });

          test( "should call configureShowingImages when running in Preview and full list is now managed", () => {
            RisePlayerConfiguration.isPreview = () => true;

            element._validFiles = [ "risemedialibrary-abc123/testing/a.jpg", "risemedialibrary-abc123/testing/b.jpg", "risemedialibrary-abc123/testing/c.jpg" ];
            element.managedFiles = [ {
              filePath: "risemedialibrary-abc123/testing/a.jpg",
              fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/testing/a.jpg",
              order: 0
            }, {
                filePath: "risemedialibrary-abc123/testing/b.jpg",
                fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/testing/b.jpg",
                order: 1
            }, {
              filePath: "risemedialibrary-abc123/testing/c.jpg",
              fileUrl: "https://storage.googleapis.com/risemedialibrary-abc123/testing/c.jpg",
              order: 2
            } ]

            element.watchedFileAddedCallback();

            assert.isTrue( element._configureShowingImages.called );
          });
        });

        suite( "_revokeObjectUrl", () => {
          setup( () => {
            sinon.stub(URL, "revokeObjectURL");
            RisePlayerConfiguration.isPreview = () => true;
            element.$.image.src = "test object url";
          } );

          teardown( () => {
            URL.revokeObjectURL.restore();
            RisePlayerConfiguration.isPreview = () => false;
          } );

          test( "should revoke object url", () => {
            element._revokeObjectUrl();

            assert.isTrue(URL.revokeObjectURL.called);
          } );

          test( "should not execute revoke if src is empty", () => {
            element.$.image.src = "";
            element._revokeObjectUrl();

            assert.isFalse(URL.revokeObjectURL.called);
          } );

          test( "should not execute revoke if not running in Preview", () => {
            RisePlayerConfiguration.isPreview = () => false;
            element._revokeObjectUrl();

            assert.isFalse(URL.revokeObjectURL.called);
          } );
        } );

        suite( "image event listeners", () => {
          setup( () => {
            sinon.stub(element, "_revokeObjectUrl");
          } );

          teardown( () => {
            element._revokeObjectUrl.restore();
          } );

          test("should call _revokeObjectUrl() when image successfully loaded", () => {
            element.$.image.dispatchEvent( new CustomEvent( "loaded-changed", { detail: { value: true } } ));

            assert.isTrue(element._revokeObjectUrl.called);
          });

          test("should call _revokeObjectUrl() when image failed to load", () => {
            element._filesToRenderList = ["test.jpg"];
            element.$.image.dispatchEvent( new CustomEvent( "error-changed", { detail: { value: true } } ));

            assert.isTrue(element._revokeObjectUrl.called);
          });
        } );

        suite( "_filterDeletedFilesForPreview", () => {
          setup( () => {
            element = fixture( "test-block" );
          });

          test( "should return empty array if files param is invalid", () => {
            assert.deepEqual(element._filterDeletedFilesForPreview(), []);
            assert.deepEqual(element._filterDeletedFilesForPreview("test"), []);
            assert.deepEqual(element._filterDeletedFilesForPreview(123), []);
          } );

          test( "should return list of files with deleted files filtered out as per metadata", () => {
            element.metadata = [ { file: "test1.jpg", exists: true }, { file: "test2.jpg", exists: false }, { file: "test3.jpg", exists: true } ];

            assert.deepEqual(element._filterDeletedFilesForPreview(["test1.jpg", "test2.jpg", "test3.jpg"]), [
              "test1.jpg", "test3.jpg"
            ]);
          } );

          test( "should return correct list of files when no metadata exists", () => {
            const list = ["test1.jpg", "test2.jpg", "test3.jpg"];

            assert.deepEqual(element._filterDeletedFilesForPreview(list), list);
          } );
        } );

      });
    </script>
  </body>
</html>
